# Darwinian Analyst Swarm
---

![License](https://img.shields.io/badge/license-MIT-blue.svg) ![Python](https://img.shields.io/badge/python-3.10%2B-blue) ![LangChain](https://img.shields.io/badge/LangGraph-Agentic-orange) ![Gemini](https://img.shields.io/badge/Powered%20By-Gemini%201.5-8E75B2)

> **"A self-correcting AI workforce that reads, reasons, and trades faster than any human."**

### *AI Agents that Read, Reason, and Trade.*
![Project Thumbnail Header](Screenshot 2025-11-27 10.56.18 AM.png)

---

## üìñ Project Overview

**The Problem:**
In the financial world, information is infinite, but attention is scarce. By the time a human trader reads a report on a tech regulation change in the EU or a startup breakthrough in Asia, the market has already moved. Traditional trading bots are brittle; they follow strict `if/then` rules and cannot understand nuance, sentiment, or conflicting reports.

**The Solution:**
The **Darwinian Analyst Swarm** is an autonomous multi-agent system fueled by **Google Gemini**. Instead of a single script, it deploys a "team" of AI agents:
1.  **News Hunter:** Scours the web for real-time data.
2.  **Analyst Swarm:** Multiple AI personas debate the significance of the news.
3.  **Portfolio Manager:** A "Judge" agent that weighs the arguments and makes the final executive decision.
4.  **Trader:** Executes the trade via the Alpaca API.

---

## üèóÔ∏è Architecture

This project uses **LangGraph** to create a stateful, cyclic workflow. Unlike linear chains, this graph allows agents to pass "memory" (state) back and forth, enabling complex reasoning.

### The Flow
1.  **Input:** User provides a stock ticker (e.g., `$NVDA`).
2.  **Ingestion:** The **News Hunter** uses DuckDuckGo to fetch live financial news.
3.  **Analysis (The "Swarm"):** The **Analyst Agent** (Gemini 1.5) reads the raw text, filtering out noise and assigning a sentiment score based on reasoning.
4.  **Decision:** The **Portfolio Manager** reviews the Analyst's findings. It acts as a risk gatekeeper‚Äîonly approving trades with high conviction.
5.  **Execution:** If approved, the **Trader Agent** connects to the **Alpaca Paper Trading API** to execute the buy/sell order in real-time.

![Architecture Workflow Diagram](Gemini_Generated_Image_g8dm7yg8dm7yg8dm.png)
*(Detailed agentic workflow flow diagram)*

---

## üöÄ Features

* **Multi-Agent Collaboration:** Agents have distinct roles and responsibilities.
* **Tool Use:** Agents autonomously use search tools to find fresh data.
* **Reasoning Engine:** Uses **Gemini 1.5 Flash/Pro** to understand context, not just keywords.
* **Real-Time Execution:** Integrated with Alpaca Markets for live paper trading.
* **Modular Design:** Built on LangChain/LangGraph, making it easy to add new "Analyst Personas" later.

---

## üõ†Ô∏è Technology Stack

* **Language:** Python 3.10+
* **Orchestration:** LangChain & LangGraph
* **LLM (Brain):** Google Gemini 1.5 Flash
* **Brokerage (Action):** Alpaca Trade API (Paper Trading)
* **Search (Data):** DuckDuckGo Search

---

## üß© Core Workflow Implementation

The heart of this agent is `workflow.py`. Below is the logical flow using **LangGraph**, which defines how agents pass the "State" (information) between one another.

```python
# --- 1. DEFINE THE SHARED STATE ---
# This is the "memory" that gets passed between agents.
class AgentState(TypedDict):
    ticker: str             # The stock symbol (e.g., "NVDA")
    news_data: List[str]    # Raw search results from DuckDuckGo
    analyst_opinions: str   # The reasoning generated by Gemini
    final_decision: str     # BUY, SELL, or HOLD
    trade_executed: bool    # Status flag

# --- 2. DEFINE THE AGENTS (NODES) ---

def news_hunter_agent(state: AgentState):
    """
    Role: Data Ingestion
    Action: Uses DuckDuckGo to find the latest financial news.
    """
    print(f"üïµÔ∏è‚Äç‚ôÇÔ∏è NEWS HUNTER: Searching for {state['ticker']}...")
    search = DuckDuckGoSearchRun()
    results = search.invoke(f"latest financial news {state['ticker']} stock today")
    return {"news_data": [results]}

def analyst_swarm_agent(state: AgentState):
    """
    Role: Reasoning Engine (Gemini 1.5)
    Action: Reads raw news, filters noise, and provides a sentiment rating.
    """
    print("üß† ANALYST SWARM: Analyzing sentiment...")
    prompt = f"""
    You are a Senior Wall Street Analyst. Analyze this news for {state['ticker']}:
    {state['news_data'][0]}
    Provide concise reasoning and a rating: BUY, HOLD, or SELL.
    """
    response = llm.invoke([HumanMessage(content=prompt)])
    return {"analyst_opinions": response.content}

def portfolio_manager_agent(state: AgentState):
    """
    Role: Risk Manager / Decision Maker
    Action: Reviews the analyst's opinion and makes the final executive call.
    """
    print("‚öñÔ∏è MANAGER: Reviewing opinions...")
    prompt = f"""
    Review this analyst opinion: {state['analyst_opinions']}
    Decide the final action. Return ONLY one word: BUY, SELL, or HOLD.
    """
    decision = llm.invoke([HumanMessage(content=prompt)]).content.strip().upper()
    return {"final_decision": decision}

def execution_agent(state: AgentState):
    """
    Role: Execution (Alpaca API)
    Action: If decision is BUY/SELL, execute the trade via API.
    """
    decision = state['final_decision']
    if decision in ["BUY", "SELL"]:
        print(f"üí∏ TRADER: Executing {decision}...")
        # (Alpaca API call logic goes here)
        return {"trade_executed": True}
    return {"trade_executed": False}

# --- 3. BUILD THE GRAPH ---
workflow = StateGraph(AgentState)

# Add Nodes
workflow.add_node("news_hunter", news_hunter_agent)
workflow.add_node("analyst_swarm", analyst_swarm_agent)
workflow.add_node("portfolio_manager", portfolio_manager_agent)
workflow.add_node("execution_trader", execution_agent)

# Define the Flow (Edges)
workflow.set_entry_point("news_hunter")
workflow.add_edge("news_hunter", "analyst_swarm")
workflow.add_edge("analyst_swarm", "portfolio_manager")
workflow.add_edge("portfolio_manager", "execution_trader")
workflow.add_edge("execution_trader", END)

app = workflow.compile()

## ‚öôÔ∏è Installation & Setup

### 1. Clone the Repository
```bash
git clone [https://github.com/YOUR_USERNAME/darwinian-analyst-swarm.git](https://github.com/YOUR_USERNAME/darwinian-analyst-swarm.git)
cd darwinian-analyst-swarm
